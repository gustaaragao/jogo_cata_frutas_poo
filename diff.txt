diff --git a/src/.idea/artifacts/jogo_cata_frutas_poo_jar.xml b/src/.idea/artifacts/jogo_cata_frutas_poo_jar.xml
deleted file mode 100644
index 7db123a..0000000
--- a/src/.idea/artifacts/jogo_cata_frutas_poo_jar.xml
+++ /dev/null
@@ -1,9 +0,0 @@
-<component name="ArtifactManager">
-  <artifact type="jar" name="jogo_cata_frutas_poo:jar">
-    <output-path>$PROJECT_DIR$/out/artifacts/jogo_cata_frutas_poo_jar</output-path>
-    <root id="archive" name="jogo_cata_frutas_poo.jar">
-      <element id="module-output" name="jogo_cata_frutas_poo" />
-      <element id="extracted-dir" path="$PROJECT_DIR$/libraries/jaco-mp3-player-0.9.3.jar" path-in-jar="/" />
-    </root>
-  </artifact>
-</component>
\ No newline at end of file
diff --git a/src/.idea/misc.xml b/src/.idea/misc.xml
index cd02460..1b2d693 100644
--- a/src/.idea/misc.xml
+++ b/src/.idea/misc.xml
@@ -1,9 +1,5 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <project version="4">
-  <component name="JavadocGenerationManager">
-    <option name="OUTPUT_DIRECTORY" value="$PROJECT_DIR$/../doc" />
-    <option name="OPTION_INCLUDE_LIBS" value="true" />
-  </component>
   <component name="ProjectRootManager" version="2" languageLevel="JDK_22" default="true" project-jdk-name="22" project-jdk-type="JavaSDK">
     <output url="file://$PROJECT_DIR$/out" />
   </component>
diff --git a/src/META-INF/MANIFEST.MF b/src/META-INF/MANIFEST.MF
deleted file mode 100644
index 6075f4b..0000000
--- a/src/META-INF/MANIFEST.MF
+++ /dev/null
@@ -1,3 +0,0 @@
-Manifest-Version: 1.0
-Main-Class: modelo.Main
-
diff --git a/src/interfaceVisual/componentes/BtnCelulaTerreno.java b/src/interfaceVisual/componentes/BtnCelulaTerreno.java
index 27cc44e..5f69545 100644
--- a/src/interfaceVisual/componentes/BtnCelulaTerreno.java
+++ b/src/interfaceVisual/componentes/BtnCelulaTerreno.java
@@ -8,45 +8,26 @@ import java.awt.*;
 import java.awt.event.MouseAdapter;
 import java.awt.event.MouseEvent;
 
-/**
- * A classe {@code BtnCelulaTerreno} estende {@link JButton} e é utilizada para criar botões que representam
- * células de terreno em um mapa. Ela parametriza o botão, definindo o ícone da célula e ajustando o comportamento
- * visual do botão quando o mouse interage com ele.
- */
 public class BtnCelulaTerreno extends JButton {
-
-    /**
-     * Construtor que cria um botão personalizado para representar uma célula de terreno no mapa.
-     * O botão utiliza a imagem correspondente à célula, recebida como parâmetro.
-     *
-     * @param celulaTerreno  A instância de {@link CelulaTerreno} que contém as informações da célula que será
-     *                       representada pelo botão.
-     * @param pacoteTextura  O caminho para o pacote de texturas que contém a imagem a ser usada como ícone do botão.
-     */
     public BtnCelulaTerreno(CelulaTerreno celulaTerreno, String pacoteTextura) {
         super();
 
-        // Define o ícone do botão com base na célula do terreno e no pacote de texturas fornecido
         ImageIcon icon = celulaTerreno.toImageIcon(pacoteTextura);
+
         setIcon(icon);
 
-        // Remove margens do botão para ajustar ao tamanho da célula
         setMargin(new Insets(0, 0, 0, 0));
 
-        // Remove a borda padrão do botão
         setBorder(BorderFactory.createEmptyBorder());
 
-        // Adiciona um listener para mudar a borda quando o mouse interage com o botão
         addMouseListener(new MouseAdapter() {
             @Override
             public void mouseEntered(MouseEvent e) {
-                // Define uma borda preta fina quando o mouse está sobre o botão
                 setBorder(BorderFactory.createLineBorder(Color.BLACK, 1));
             }
 
             @Override
             public void mouseExited(MouseEvent e) {
-                // Remove a borda quando o mouse sai do botão
                 setBorder(BorderFactory.createEmptyBorder());
             }
         });
diff --git a/src/interfaceVisual/componentes/PainelInterfaceJogador.java b/src/interfaceVisual/componentes/PainelInterfaceJogador.java
index 5a98972..99d526a 100644
--- a/src/interfaceVisual/componentes/PainelInterfaceJogador.java
+++ b/src/interfaceVisual/componentes/PainelInterfaceJogador.java
@@ -3,26 +3,10 @@ package interfaceVisual.componentes;
 import javax.swing.*;
 import java.awt.*;
 
-/**
- * A classe {@code PainelInterfaceJogador} estende {@link JPanel} e é utilizada para representar a interface do jogador,
- * onde futuramente será exibido o menu do jogador.
- * Atualmente, o painel é configurado de forma temporária com um fundo azul e um layout absoluto.
- */
 public class PainelInterfaceJogador extends JPanel {
-
-    /**
-     * Construtor padrão que inicializa o painel com configurações temporárias.
-     * O painel tem fundo azul e está posicionado à direita do mapa com um layout absoluto.
-     * No futuro, essa área será usada para o menu do jogador.
-     */
     public PainelInterfaceJogador() {
-        // Define o layout absoluto (null layout)
         setLayout(null);
-
-        // Define a cor de fundo temporária como azul
         setBackground(Color.BLUE); // Temporário
-
-        // Define as dimensões e posição do painel
         setBounds(624, 0, 400, 624);
     }
-}
+}
\ No newline at end of file
diff --git a/src/interfaceVisual/componentes/PainelMapa.java b/src/interfaceVisual/componentes/PainelMapa.java
index 3b0e4fc..e4c28d5 100644
--- a/src/interfaceVisual/componentes/PainelMapa.java
+++ b/src/interfaceVisual/componentes/PainelMapa.java
@@ -7,87 +7,58 @@ import modelo.utils.Randomizador;
 import javax.swing.*;
 import java.awt.*;
 
-/**
- * A classe {@code PainelMapa} estende {@link JPanel} e é responsável por exibir graficamente o mapa do jogo.
- * Ela renderiza as células do terreno como botões e centraliza o grid de células dentro do painel.
- */
 public class PainelMapa extends JPanel {
 
-    private Mapa mapa;               // Mapa que contém a estrutura das células do terreno
-    private String pacoteTextura;    // Pacote de texturas a ser usado para os ícones das células
+    Mapa mapa;
+    String pacoteTextura;
 
-    /**
-     * Construtor padrão que inicializa o painel do mapa com um layout nulo e uma cor de fundo.
-     * O construtor também define o pacote de textura aleatoriamente utilizando o {@link Randomizador}.
-     */
     public PainelMapa() {
-        // Define o layout absoluto (null layout)
         setLayout(null);
-
-        // Define uma cor de fundo temporária
         setBackground(Color.LIGHT_GRAY);  // Cor de fundo para visualizar a área reservada
-
-        // Define o tamanho e posição do painel
         setBounds(0, 0, 624, 624);
 
-        // Sorteia um pacote de textura para ser usado no mapa
         this.pacoteTextura = Randomizador.sortearPacoteTextura();
     }
 
-    /**
-     * Define o mapa que será renderizado no painel.
-     *
-     * @param mapa O objeto {@link Mapa} que contém as células do terreno.
-     */
     public void setMapa(Mapa mapa) {
         this.mapa = mapa;
     }
 
-    /**
-     * Atualiza a renderização do mapa no painel.
-     * Esse método cria e posiciona os botões que representam as células do terreno,
-     * centralizando o grid no painel.
-     */
     public void atualizarMapa() {
-        // Define a dimensão máxima para o grid, com limite de 12x12 células
+        // Isso daqui é temporário. Remover quando unirmos as telas de GerarMapa com o de Jogo.
         int dimensao = Math.min(mapa.getDimensao(), 12);
 
-        // Obtém a matriz de células do mapa
         CelulaTerreno[][] floresta = mapa.getFloresta();
 
-        // Define o tamanho de cada botão de célula de terreno
         int tamanhoBtnCelulaTerreno = 50;
 
-        // Calcula as dimensões totais do grid
+        // Dimensões totais do grid
         int larguraGrid = dimensao * tamanhoBtnCelulaTerreno;
         int alturaGrid = dimensao * tamanhoBtnCelulaTerreno;
 
-        // Calcula a posição inicial para centralizar o grid dentro do painel de 624x624
+        // Calcula a posição inicial para centralizar o grid no painel de 624x624
         int startX = (this.getWidth() - larguraGrid) / 2;
         int startY = (this.getHeight() - alturaGrid) / 2;
 
-        // Remove os componentes antigos, caso o mapa esteja sendo atualizado
+        // Remove os componentes antigos (caso esteja atualizando o mapa)
         this.removeAll();
 
-        // Cria e posiciona os botões que representam as células do terreno
+        // Cria o grid de botões e os posiciona no painel centralizado
         for (int i = 0; i < dimensao; i++) {
             for (int j = 0; j < dimensao; j++) {
-                // Cria o botão para a célula de terreno e define o pacote de texturas
+                // Cria o botão e define seu tamanho e posição
                 BtnCelulaTerreno btnCelulaTerreno = new BtnCelulaTerreno(floresta[i][j], this.pacoteTextura);
 
-                // Calcula a posição do botão no grid
                 int posicaoX = startX + j * tamanhoBtnCelulaTerreno;
                 int posicaoY = startY + i * tamanhoBtnCelulaTerreno;
 
-                // Define o tamanho e posição do botão no painel
                 btnCelulaTerreno.setBounds(posicaoX, posicaoY, tamanhoBtnCelulaTerreno, tamanhoBtnCelulaTerreno);
 
-                // Adiciona o botão ao painel
                 this.add(btnCelulaTerreno);
             }
         }
 
-        // Atualiza o layout e repinta o painel após adicionar os componentes
+        // Atualiza o layout do painel de mapa e do painel principal
         this.revalidate();
         this.repaint();
     }
diff --git a/src/interfaceVisual/fontes/Press_Start_2P/PressStartFont.java b/src/interfaceVisual/fontes/Press_Start_2P/PressStartFont.java
index 2995907..76cb943 100644
--- a/src/interfaceVisual/fontes/Press_Start_2P/PressStartFont.java
+++ b/src/interfaceVisual/fontes/Press_Start_2P/PressStartFont.java
@@ -3,13 +3,8 @@ package interfaceVisual.fontes.Press_Start_2P;
 import java.awt.*;
 import java.io.InputStream;
 
-/** Gerencia a configuração da fonte externa Press_Start_2P.
- */
 public class PressStartFont {
     private Font pressStart;
-
-    /** O construtor inicializa a fonte pelo caminho do arquivo dela e define algumas configurações padrão.
-     */
     public PressStartFont() {
         try {
             InputStream is = getClass().getResourceAsStream("./PressStart2P-Regular.ttf");
@@ -20,9 +15,6 @@ public class PressStartFont {
         }
     }
 
-    /** O construtor com o size recebe um valor inteiro e inicializa a fonte com o tamanho = size.
-     * @param size
-     */
     public PressStartFont(int size) {
         try {
             InputStream is = getClass().getResourceAsStream("./PressStart2P-Regular.ttf");
@@ -37,9 +29,6 @@ public class PressStartFont {
         return pressStart;
     }
 
-    /** Define o tamanho da fonte
-     * @param tamanho
-     */
     public void setFontSize(int tamanho) {
         pressStart.deriveFont(Font.PLAIN, tamanho);
     }
diff --git a/src/interfaceVisual/soundtrack/ReprodutorDeSom.java b/src/interfaceVisual/soundtrack/ReprodutorDeSom.java
index 37d2a16..0d9f0af 100644
--- a/src/interfaceVisual/soundtrack/ReprodutorDeSom.java
+++ b/src/interfaceVisual/soundtrack/ReprodutorDeSom.java
@@ -4,17 +4,11 @@ import jaco.mp3.player.MP3Player;
 
 import java.io.File;
 
-/** Gerencia as mídias de som do programa, como a música e os efeitos sonoros.
- */
 public class ReprodutorDeSom {
       private MP3Player player;
       private static MP3Player botaoPlayer;
 
     boolean isAtivo;
-
-    /** O construtor recebe o caminho de um arquivo de áudio mp3 e toca ele em loop.
-     * @param string
-     */
     public ReprodutorDeSom(String string) {
         try{
             File file = new File(string);
@@ -36,16 +30,11 @@ public class ReprodutorDeSom {
         isAtivo = valor;
     }
 
-    /** Toca o som armazenado na classe em loop.
-     */
     public void tocarSom() {
         player.setRepeat(true);
         player.play();
     }
 
-    /** Recebe o caminho de um arquivo de som mp3 e o toca apenas uma vez.
-     * @param caminho
-     */
     public void tocarSom(String caminho) {
         try{
             new MP3Player(new File(caminho)).play();
@@ -55,8 +44,6 @@ public class ReprodutorDeSom {
         }
     }
 
-    /** Reproduz o efeito sonoro dos botões.
-     */
     public static void tocarBotao() {
         try {
             botaoPlayer = new MP3Player(new File("./interfaceVisual/soundtrack/pressionarBotao.mp3"));
@@ -67,8 +54,6 @@ public class ReprodutorDeSom {
         }
     }
 
-    /** Pausa a música armazenada na classe.
-     */
     public void pausarSom() {
         player.pause();
     }
diff --git a/src/interfaceVisual/telasStatePattern/Frame.java b/src/interfaceVisual/telasStatePattern/Frame.java
index d8e72d5..4c47f30 100644
--- a/src/interfaceVisual/telasStatePattern/Frame.java
+++ b/src/interfaceVisual/telasStatePattern/Frame.java
@@ -2,11 +2,11 @@ package interfaceVisual.telasStatePattern;
 
 import interfaceVisual.soundtrack.ReprodutorDeSom;
 
+import javax.imageio.ImageIO;
 import javax.swing.*;
 import java.awt.*;
+import java.awt.image.BufferedImage;
 
-/** Define a janela principal da interface gráfica do jogo.
- */
 public class Frame{
     private Tela start;
     private Tela menu;
@@ -23,10 +23,6 @@ public class Frame{
     private JFrame frame;
     private ReprodutorDeSom reprodutorDeSom;
 
-    /**
-     * O construtor estabelece a configuração do JFrame e inicializa as telas do jogo, bem como o
-     * reprodutor musical.
-     */
     public Frame(){
         frame = new JFrame("Cata-Frutas");
         frame.setSize(1024 + 16,624 + 39);
@@ -53,10 +49,7 @@ public class Frame{
         //tem terreno e comecou partida são falsos quando instanciados.
         frame.setVisible(true);
     }
-
-    /** Altera a tela do frame pela nova passada como parâmetro.
-     * @param novaTela
-     */
+	
     public void setState(Tela novaTela){
         frame.remove(atual.getPanel());
         this.atual = novaTela;
diff --git a/src/interfaceVisual/telasStatePattern/Preview.java b/src/interfaceVisual/telasStatePattern/Preview.java
index 8f2422c..eccaf73 100644
--- a/src/interfaceVisual/telasStatePattern/Preview.java
+++ b/src/interfaceVisual/telasStatePattern/Preview.java
@@ -1,13 +1,13 @@
 package interfaceVisual.telasStatePattern;
 
-import interfaceVisual.componentes.PainelMapa;
 import modelo.mapa.Mapa;
 
 import javax.swing.*;
+import java.awt.*;
 
 public class Preview {
     JFrame frame;
-    JPanel panel;
+    Jogo jogo;
 
     public Preview(Mapa mapa) {
         frame = new JFrame("Preview");
@@ -17,18 +17,9 @@ public class Preview {
         frame.setLocationRelativeTo(null);
         frame.setResizable(false);
 
-        //MapaPreview mapaPreview = new MapaPreview(frame, mapa);
-        panel = new JPanel();
-        panel.setLayout(null);
-        panel.setBounds(0, 0, 624, 624);
-
-        PainelMapa painelMapa = new PainelMapa();
-        painelMapa.setMapa(mapa);
-        painelMapa.atualizarMapa();
-
-        panel.add(painelMapa);
-
-        frame.add(panel);
+        MapaPreview mapaPreview = new MapaPreview(frame, mapa);
+        
+        frame.add(mapaPreview.getPanel());
         frame.setVisible(true);
     }
 }
diff --git a/src/modelo/Main.java b/src/modelo/Main.java
index 64b9591..fcee87f 100644
--- a/src/modelo/Main.java
+++ b/src/modelo/Main.java
@@ -1,10 +1,12 @@
 package modelo;
 
 import interfaceVisual.telasStatePattern.Frame;
+
 import interfaceVisual.telasStatePattern.Jogo;
 import modelo.arquivo.GerenciadorMapaArquivo;
 import modelo.mapa.*;
 import modelo.utils.Randomizador;
+
 /**
  * Essa classe é atualmente o ponto de partida do programa.
  * Sua única função é iniciar a interface gráfica com o jogador.
@@ -12,22 +14,10 @@ import modelo.utils.Randomizador;
  *
  * @see interfaceVisual.telasStatePattern.Frame
  */
-
 public class Main {
 
 	public static void main(String[] args) {
-
-		MapaConfiguracao configuracaoDoMapa = GerenciadorMapaArquivo.importarArquivoTerreno("./input.txt");
-		assert configuracaoDoMapa != null;
-
-		Mapa mapa = new Mapa(configuracaoDoMapa, 2);
-		mapa.visualizarTerreno();
-
 		Frame frame = new Frame();
-
-		Jogo jogo = ((Jogo) frame.getJogo());
-
-		jogo.inicializarMapa(mapa);
 	}
 }
 
diff --git a/src/modelo/arquivo/GerenciadorMapaArquivo.java b/src/modelo/arquivo/GerenciadorMapaArquivo.java
index dd60b40..b2b04e0 100644
--- a/src/modelo/arquivo/GerenciadorMapaArquivo.java
+++ b/src/modelo/arquivo/GerenciadorMapaArquivo.java
@@ -5,30 +5,10 @@ import modelo.mapa.MapaConfiguracao;
 import java.util.Arrays;
 import java.io.*;
 
-/**
- * A classe {@code GerenciadorMapaArquivo} fornece métodos para importar e exportar configurações
- * de mapas de terreno de arquivos de texto. Ela permite ler as configurações de um arquivo e criar
- * um objeto {@link MapaConfiguracao} correspondente, bem como exportar a configuração de um mapa
- * para um arquivo de texto.
- * <p>
- * As funções utilizam {@link BufferedReader} e {@link BufferedWriter} para ler e escrever nos
- * arquivos de maneira eficiente.
- * </p>
- */
 public class GerenciadorMapaArquivo {
 
-    /**
-     * Importa um arquivo de texto contendo as configurações de um mapa de terreno.
-     * <p>
-     * O arquivo deve ter configurações como dimensão, quantidade de pedras, probabilidade de frutas bichadas,
-     * tamanho da mochila e a quantidade de frutas específicas. A leitura será feita linha por linha, 
-     * com cada configuração separada por espaços.
-     * </p>
-     *
-     * @param caminhoArquivo O caminho do arquivo a ser importado.
-     * @return Um {@link MapaConfiguracao} contendo as configurações lidas do arquivo, ou {@code null}
-     *         caso ocorra algum erro durante a leitura do arquivo.
-     */
+    // Para as funções a seguir eu usei a seguinte referência: https://www.geeksforgeeks.org/java-io-bufferedreader-class-java/
+
     public static MapaConfiguracao importarArquivoTerreno(String caminhoArquivo) {
         BufferedReader br = null;
         MapaConfiguracao configMapa = new MapaConfiguracao();
@@ -55,10 +35,9 @@ public class GerenciadorMapaArquivo {
                     case "mochila":
                         configMapa.setTamanhoMochila(Integer.parseInt(partesLinhas[1]));
                         break;
-                    default: 
-                        if (Arrays.asList(FrutasValidas).contains(partesLinhas[0].toLowerCase())) {
-                            configMapa.qntFrutasPorTipo.put(partesLinhas[0].toLowerCase(), new QuantidadeFrutas(Integer.parseInt(partesLinhas[1]), Integer.parseInt(partesLinhas[2])));
-                        }
+                    default: if (Arrays.asList(FrutasValidas).contains(partesLinhas[0].toLowerCase())) {
+                        configMapa.qntFrutasPorTipo.put(partesLinhas[0].toLowerCase(),new QuantidadeFrutas(Integer.parseInt(partesLinhas[1]), Integer.parseInt(partesLinhas[2]))); 
+                    }
                 }
             }
 
@@ -84,16 +63,6 @@ public class GerenciadorMapaArquivo {
         return null; // Retorna null caso haja erro na leitura do arquivo
     }
 
-    /**
-     * Exporta as configurações de um {@link MapaConfiguracao} para um arquivo de texto.
-     * <p>
-     * As configurações do mapa serão convertidas em texto e escritas no arquivo especificado.
-     * O arquivo criado poderá ser lido posteriormente utilizando o método {@link #importarArquivoTerreno(String)}.
-     * </p>
-     *
-     * @param caminhoArquivo       O caminho do arquivo para exportar as configurações.
-     * @param configuracaoDoMapa   Um objeto {@link MapaConfiguracao} que contém as configurações a serem exportadas.
-     */
     public static void exportarArquivoTerreno(String caminhoArquivo, MapaConfiguracao configuracaoDoMapa) {
         BufferedWriter bw = null;
 
diff --git a/src/modelo/arquivo/VerificadorMapaArquivo.java b/src/modelo/arquivo/VerificadorMapaArquivo.java
index a046806..5211b53 100644
--- a/src/modelo/arquivo/VerificadorMapaArquivo.java
+++ b/src/modelo/arquivo/VerificadorMapaArquivo.java
@@ -4,12 +4,6 @@ import modelo.tipos.QuantidadeFrutas;
 
 import java.util.Random;
 
-/**
- * A classe {@code VerificadorMapaArquivo} é responsável por gerenciar e verificar as configurações de um mapa que
- * contém frutas, pedras e outros objetos. Esta classe define e controla a distribuição de elementos no mapa, como
- * frutas de ouro, frutas diversas e pedras, além de verificar o espaço disponível e ajustar os valores conforme
- * necessário.
- */
 public class VerificadorMapaArquivo {
 
     private int dimensao;
@@ -36,10 +30,6 @@ public class VerificadorMapaArquivo {
 
     private static Random random = new Random(System.currentTimeMillis());
 
-    /**
-     * Construtor padrão que inicializa o mapa com valores padrão e calcula o espaço disponível com base nos
-     * elementos iniciais.
-     */
 	public VerificadorMapaArquivo() {
         dimensao = 5;
         espacoDisponivel = dimensao*dimensao;
@@ -57,32 +47,26 @@ public class VerificadorMapaArquivo {
         frutasOuroTotais = frutasOuroChao + frutasOuroASurgir;
 
         frutasDiversas = 8;
-        distribuirFrutas();
+
+        laranja = 0;
+        abacate = 0;
+        coco = 0;
+        acerola = 0;
+        amora = 0;
+        goiaba = 0;
 
         chanceBichada = 25;
 
         tamanhoMochila = frutasOuroTotais/2 + 1;
 
         espacoDisponivel = espacoDisponivel - (pedras + arvLaranja + arvAbacate +
-                arvAmora + arvAcerola + arvGoiaba + arvCoco + frutasOuroChao + frutasDiversas) - 2;
+                arvAmora + arvAcerola + arvGoiaba + arvCoco + frutasOuroChao + frutasDiversas);
     }
 
-    /**
-     * Retorna a dimensão atual do mapa.
-     *
-     * @return a dimensão do mapa.
-     */
     public int getDimensao() {
         return dimensao;
     }
 
-    /**
-     * Define uma nova dimensão para o mapa. O valor da dimensão deve estar entre 5 e 12, e o espaço disponível
-     * deve ser suficiente para a nova dimensão.
-     *
-     * @param dimensao a nova dimensão desejada.
-     * @return {@code true} se a nova dimensão for válida e for possível aplicar; {@code false} caso contrário.
-     */
     public boolean setDimensao(int dimensao) {
         if (dimensao < 5 || dimensao > 12)
             return false;
@@ -102,24 +86,10 @@ public class VerificadorMapaArquivo {
         }
     }
 
-
-    /**
-     * Retorna a quantidade de frutas de ouro no chão.
-     *
-     * @return a quantidade de frutas de ouro no chão.
-     */
     public int getFrutasOuroChao() {
         return frutasOuroChao;
     }
 
-
-    /**
-     * Define a quantidade de frutas de ouro no chão. O valor deve ser maior ou igual a zero e não pode exceder
-     * o espaço disponível.
-     *
-     * @param frutasOuroChao a nova quantidade de frutas de ouro no chão.
-     * @return {@code true} se o valor for válido e a alteração puder ser feita; {@code false} caso contrário.
-     */
     public boolean setFrutasOuroChao(int frutasOuroChao) {
         if (espacoDisponivel < 1 && frutasOuroChao > this.frutasOuroChao)
             return false;
@@ -141,21 +111,10 @@ public class VerificadorMapaArquivo {
         }
     }
 
-    /**
-     * Retorna a quantidade de frutas de ouro que irão surgir.
-     *
-     * @return a quantidade de frutas de ouro a surgir.
-     */
     public int getFrutasOuroASurgir() {
         return frutasOuroASurgir;
     }
 
-    /**
-     * Define a quantidade de frutas de ouro que irão surgir no futuro. O valor deve ser maior ou igual a zero.
-     *
-     * @param frutasOuroASurgir a nova quantidade de frutas de ouro a surgir.
-     * @return {@code true} se o valor for válido e a alteração puder ser feita; {@code false} caso contrário.
-     */
     public boolean setFrutasOuroASurgir(int frutasOuroASurgir) {
         if (frutasOuroASurgir < 0)
             return false;
@@ -171,11 +130,6 @@ public class VerificadorMapaArquivo {
         }
     }
 
-    /**
-     * Retorna a quantidade total de frutas de ouro no mapa (somatório das frutas de ouro no chão e as que irão surgir).
-     *
-     * @return a quantidade total de frutas de ouro.
-     */
     public int getFrutasOuroTotais() {
         frutasOuroTotais = frutasOuroChao + frutasOuroASurgir;
         return frutasOuroTotais;
@@ -187,22 +141,10 @@ public class VerificadorMapaArquivo {
     }
      */
 
-    /**
-     * Retorna a quantidade de frutas diversas no mapa.
-     *
-     * @return a quantidade de frutas diversas.
-     */
     public int getFrutasDiversas() {
         return frutasDiversas;
     }
 
-    /**
-     * Define a quantidade de frutas diversas no mapa. O valor deve ser maior ou igual a zero e não pode exceder
-     * o espaço disponível.
-     *
-     * @param frutasDiversas a nova quantidade de frutas diversas.
-     * @return {@code true} se o valor for válido e a alteração puder ser feita; {@code false} caso contrário.
-     */
     public boolean setFrutasDiversas(int frutasDiversas) {
         if (espacoDisponivel < 1 && frutasDiversas > this.frutasDiversas)
             return false;
@@ -214,38 +156,10 @@ public class VerificadorMapaArquivo {
             else
                 espacoDisponivel--;
             this.frutasDiversas = frutasDiversas;
-            switch (random.nextInt(6)) {
-                case(0):
-                    laranja++;
-                    break;
-                case(1):
-                    abacate++;
-                    break;
-                case(2):
-                    coco++;
-                    break;
-                case(3):
-                    acerola++;
-                    break;
-                case(4):
-                    amora++;
-                    break;
-                case(5):
-                    goiaba++;
-                    break;
-                default:
-                    break;
-            }
             return true;
         }
     }
 
-    // Métodos semelhantes para chanceBichada, pedras, árvores, e distribuição de frutas seguem a mesma lógica.
-    // Os métodos set verificam as condições para ajuste e retornam verdadeiro ou falso com base na validade da operação.
-
-    /**
-     * Distribui aleatoriamente as frutas diversas entre os diferentes tipos de frutas.
-     */
     public int getChanceBichada() {
         return chanceBichada;
     }
@@ -263,13 +177,6 @@ public class VerificadorMapaArquivo {
         return pedras;
     }
 
-    /**
-     * Define a quantidade de pedras no mapa. O valor deve ser maior ou igual a zero e não pode exceder
-     * o espaço disponível.
-     *
-     * @param pedras a nova quantidade de frutas diversas.
-     * @return {@code true} se o valor for válido e a alteração puder ser feita; {@code false} caso contrário.
-     */
     public boolean setPedras(int pedras) {
         if (espacoDisponivel < 1 && pedras > this.pedras)
             return false;
@@ -285,12 +192,6 @@ public class VerificadorMapaArquivo {
         }
     }
 
-    /** Verifica o tamanho mínimo da mochila de acordo com as regras do jogo.
-     *
-     * @param frutasOuroTotais
-     * @param tamanhoMochila
-     * @return boolean
-     */
     public boolean verificarTamanhoMinimo(int frutasOuroTotais, int tamanhoMochila) {
         int aux = frutasOuroTotais/2 + 1;
         if (tamanhoMochila < aux) {
diff --git a/src/modelo/utils/Imagem.java b/src/modelo/utils/Imagem.java
index a8cb02b..f406a91 100644
--- a/src/modelo/utils/Imagem.java
+++ b/src/modelo/utils/Imagem.java
@@ -4,22 +4,9 @@ import javax.swing.*;
 import java.awt.*;
 import java.awt.image.BufferedImage;
 
-/**
- * A classe Imagem contém utilitários para manipulação e combinação de imagens.
- */
 public class Imagem {
 
-    /**
-     * Combina duas imagens, desenhando a imagem sobreposta no centro da imagem base.
-     * 
-     * <p>Este método recebe duas imagens do tipo {@link ImageIcon}, sendo que a imagem sobreposta
-     * será desenhada sobre a imagem base. A imagem final será retornada como um {@link BufferedImage}.</p>
-     *
-     * @param imagemBase       A imagem de fundo sobre a qual a segunda imagem será desenhada.
-     * @param imagemSobreposta A imagem que será desenhada no centro da imagem base.
-     * @return Um {@link BufferedImage} contendo a imagem base com a imagem sobreposta desenhada no centro.
-     * @throws IllegalArgumentException Se uma ou ambas as imagens forem inválidas (nulas).
-     */
+    // Função que combina duas imagens
     public static BufferedImage combinarImagens(ImageIcon imagemBase, ImageIcon imagemSobreposta) {
         if (imagemBase.getImage() == null || imagemSobreposta.getImage() == null) {
             throw new IllegalArgumentException("Uma ou ambas as imagens são inválidas.");
@@ -53,4 +40,4 @@ public class Imagem {
         // Retorna a imagem combinada
         return imagemCombinada;
     }
-}
+}
\ No newline at end of file
